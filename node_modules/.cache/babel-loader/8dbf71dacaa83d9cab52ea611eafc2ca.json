{"ast":null,"code":"import { d as now, i as elementTransitionEnd } from '../shared/utils.mjs';\n\nfunction freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper; // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}\n\nexport { freeMode as default };","map":{"version":3,"sources":["C:/Users/NIVESH SAITEJA/OneDrive/Documents/GitHub/MyPortfolio/node_modules/swiper/modules/free-mode.mjs"],"names":["d","now","i","elementTransitionEnd","freeMode","_ref","swiper","extendParams","emit","once","enabled","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","sticky","minimumVelocity","onTouchStart","params","cssMode","translate","getTranslate","setTranslate","setTransition","touchEventsData","velocities","length","onTouchEnd","currentPos","rtl","onTouchMove","data","touches","push","position","isHorizontal","time","touchStartTime","_ref2","wrapperEl","rtlTranslate","snapGrid","touchEndTime","timeDiff","minTranslate","slideTo","activeIndex","maxTranslate","slides","lastMoveEvent","pop","velocityEvent","distance","velocity","Math","abs","momentumDuration","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","needsLoopFix","allowMomentumBounce","loop","centeredSlides","nextSlide","j","swipeDirection","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","transitionStart","animating","destroyed","setTimeout","transitionEnd","updateActiveIndex","updateSlidesClasses","longSwipesMs","Object","assign","default"],"mappings":"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","sourcesContent":["import { d as now, i as elementTransitionEnd } from '../shared/utils.mjs';\n\nfunction freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}\n\nexport { freeMode as default };\n"]},"metadata":{},"sourceType":"module"}